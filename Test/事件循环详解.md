# JavaScript 事件循环、Promise与异步机制详解

## 1. 事件循环 (Event Loop) 基础概念

JavaScript是单线程语言，但通过事件循环机制实现了非阻塞的异步操作。事件循环的核心是一个持续运行的循环，它不断检查调用栈和任务队列。

### 1.1 执行栈 (Call Stack)
- 存储当前正在执行的函数调用
- 遵循后进先出(LIFO)原则
- 同步代码直接入栈执行

### 1.2 任务队列 (Task Queues)
- **宏任务队列 (Macrotask Queue)**：setTimeout、setInterval、I/O、UI渲染
- **微任务队列 (Microtask Queue)**：Promise.then、catch、finally、queueMicrotask

### 1.3 事件循环执行顺序
```
1. 执行同步代码（调用栈）
2. 执行所有微任务队列中的任务
3. 执行一个宏任务队列中的任务
4. 回到步骤1，循环往复
```

## 2. 宏任务 vs 微任务

| 类型 | 示例 | 优先级 | 特点 |
|---|---|---|---|
| **宏任务** | setTimeout、setInterval、setImmediate | 低 | 每个循环执行一个 |
| **微任务** | Promise.then、queueMicrotask | 高 | 全部执行完毕 |

## 3. Promise 原理详解

### 3.1 Promise 状态
- **pending**：初始状态，既不是成功也不是失败
- **fulfilled**：操作成功完成
- **rejected**：操作失败

### 3.2 Promise 构造函数
```javascript
const promise = new Promise((resolve, reject) => {
    // 执行器函数(executor)是同步执行的
    console.log("同步执行");
    
    // 异步操作
    setTimeout(() => {
        resolve("成功"); // 或 reject("失败")
    }, 1000);
});
```

### 3.3 Promise.then 链式调用
```javascript
promise
    .then(result => {
        console.log(result); // "成功"
        return "新的值"; // 返回新的Promise
    })
    .then(result => {
        console.log(result); // "新的值"
    })
    .catch(error => {
        console.log(error);
    });
```

## 4. 实际执行顺序分析

让我们分析以下代码的执行顺序：

```javascript
console.log("1. 同步代码");

setTimeout(() => {
    console.log("2. 宏任务");
}, 0);

Promise.resolve().then(() => {
    console.log("3. 微任务1");
}).then(() => {
    console.log("4. 微任务2");
});

console.log("5. 同步代码结束");
```

**执行顺序**：
1. "1. 同步代码"
2. "5. 同步代码结束"
3. "3. 微任务1"
4. "4. 微任务2"
5. "2. 宏任务"

## 5. Async/Await 语法糖

### 5.1 基本用法
```javascript
async function example() {
    try {
        const result = await Promise.resolve("成功");
        console.log(result);
    } catch (error) {
        console.log(error);
    }
}
```

### 5.2 编译原理
```javascript
// async/await 代码
async function example() {
    const result = await Promise.resolve("成功");
    return result;
}

// 等价于 Promise 代码
function example() {
    return Promise.resolve("成功")
        .then(result => result);
}
```

## 6. 常见误区与最佳实践

### 6.1 误区1：认为setTimeout(fn, 0)立即执行
```javascript
setTimeout(() => {
    console.log("宏任务");
}, 0);

Promise.resolve().then(() => {
    console.log("微任务"); // 先执行
});
```

### 6.2 误区2：忽略Promise构造函数同步执行
```javascript
new Promise(resolve => {
    console.log("同步执行"); // 立即执行
    resolve();
}).then(() => {
    console.log("微任务"); // 后执行
});
```

### 6.3 最佳实践
1. **避免嵌套setTimeout**：使用Promise链式调用
2. **错误处理**：始终添加.catch或使用try/catch
3. **性能优化**：批量操作使用Promise.all
4. **内存管理**：避免创建不必要的Promise

## 7. 实际应用场景

### 7.1 防抖(Debounce)
```javascript
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

const search = debounce((query) => {
    console.log(`搜索: ${query}`);
}, 300);
```

### 7.2 节流(Throttle)
```javascript
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}
```

### 7.3 并发控制
```javascript
// 使用Promise.all控制并发
const urls = ['url1', 'url2', 'url3'];
const promises = urls.map(url => fetch(url));

Promise.all(promises)
    .then(responses => {
        console.log("所有请求完成");
    })
    .catch(error => {
        console.log("某个请求失败", error);
    });
```

## 8. 调试技巧

### 8.1 使用console.log调试
```javascript
console.log("同步代码");

setTimeout(() => {
    console.log("宏任务执行");
}, 0);

Promise.resolve().then(() => {
    console.log("微任务执行");
});
```

### 8.2 使用Performance API
```javascript
performance.mark('start');

setTimeout(() => {
    performance.mark('timeout-end');
    performance.measure('timeout', 'start', 'timeout-end');
}, 0);

Promise.resolve().then(() => {
    performance.mark('promise-end');
    performance.measure('promise', 'start', 'promise-end');
});
```

## 9. 浏览器差异

| 浏览器 | 微任务实现 | 差异 |
|---|---|---|
| **Chrome** | MutationObserver + Promise | 标准实现 |
| **Firefox** | Promise | 微任务优先级高 |
| **Safari** | Promise | 类似Chrome |
| **Edge** | Promise | 基于Chromium |

## 10. 总结

理解JavaScript的事件循环机制对于编写高效的异步代码至关重要。记住以下关键点：

1. **同步代码优先**：所有同步代码先执行
2. **微任务优先**：微任务队列全部清空后才执行宏任务
3. **宏任务逐个**：每次事件循环只执行一个宏任务
4. **async/await**：是Promise的语法糖，基于微任务
5. **调试重要**：使用console.log和Performance API调试异步代码

通过深入理解这些概念，你将能够编写出更加高效、可靠的JavaScript异步代码。